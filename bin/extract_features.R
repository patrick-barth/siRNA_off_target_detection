#!/usr/bin/env Rscript

library(optparse)
library(ape) # parses gff
#library(string) # working with strings
library(Biostrings) # Parse fasta

#### Get arguments ##
option_list <- list(
  make_option(c("-d", "--work_dir"),      type = "character",   default = ".",
              metavar = "character",      help = "Working directory containing input files. Additionally, output will be generated here"),
  make_option(c("-b", "--db_base_dir"),   type = "character",
              metavar = "character",        help = "Base dir of the database. Necessary to extract annotation and CDS informations"),
  make_option(c("-a", "--alignments"),    type = "character",
              metavar = "character",      help = "File containing alignment results generated by BLAST"),
  make_option(c("-r", "--sirnas"),    type = "character",
              metavar = "character",      help = "siRNA sequences used for the alignment"),
  make_option(c("-i", "--group"),    type = "character",
              metavar = "character",      help = "Name of the group currently being investigated (needs to be present as DB base group)"),
  make_option(c("-c", "--get_coding_sequences"),  type = "logical",     default = FALSE, action="store_true",
              metavar = "logical",        help = "If true, coding sequence from a cds file will be extracted"),
  make_option(c("-s", "--regard_strands"),  type = "logical",     default = FALSE, action="store_true",
              metavar = "logical",        help = "If true, only siRNAs aligning to the oppsing strand will be reported"),
  make_option(c("-n", "--matching_nucleotides"),  type = "numeric",   default = "16",
              metavar = "numeric",      help = "Least amount of nucleotides matching to report a hit")
)
opt_parser  <- OptionParser(option_list = option_list)
opt         <- parse_args(opt_parser)

dir_base      <- opt$work_dir
dir_db      <- opt$db_base_dir
alignments <- opt$alignments
sirnas <- opt$sirnas
group <- opt$group
regard_strandiness <- opt$regard_strands
extract_coding_sequences <- opt$get_coding_sequences
minimum_matching_nucleotides <- opt$matching_nucleotides

# tmp arguments
group <- 'hymenoptera'
group <- 'beetle'
dir_base <- paste("/home/patrick/PhD/projects/small_projects/ledprona/2025_02_18_ledprona","/",sep = '')
dir_db <- paste("/home/patrick/PhD/projects/small_projects/ledprona/2025_02_18_ledprona/",sep = '')
alignments <- paste("/home/patrick/PhD/projects/small_projects/ledprona/2025_02_18_ledprona/blast_results_ledprona_vs_",group,".tsv",sep = '')
sirnas <- "/home/patrick/PhD/projects/small_projects/ledprona/ledprona_siRNAs.fa"
regard_strandiness = TRUE
extract_coding_sequences <- FALSE
minimum_matching_nucleotides <- 19
# end tmp arguments

availability_info_path <- paste(dir_db,"/infos.tsv",sep='')
dir_output <- paste(dir_base,"/output/",sep='')


if (!dir.exists(dir_output)) {
  dir.create(dir_output)
}

# functions
# Extracts attribute starting with given attribute_name. If not present or more than one is found NA is returned
extract_attribute_info <- function(attribute_list,attribute_name){
  feature <- attribute_list[which(startsWith(attribute_list,attribute_name))]
  if (length(feature == 1)) {
    feature <- unlist(strsplit(feature,'='))[2]
    return(feature)
  } else {
    return(NA)
  }
}

extract_locus_tag <- function(string,pattern) {
  matches <- str_match(string, pattern)
  if (!is.na(matches[2])) {
    return(matches[2])
  } else {
    return(NA)
  }
}

raw_table <- read.table(file = alignments,
                        header = FALSE,
                        col.names = c("query_id","ref_id","matches","mismatches","gaps",
                                      "strand","alignment_length","query_start","query_end","query_seq",
                                      "ref_start","ref_end","ref_seq","evalue"),
                        sep='\t')

availability_info <- read.table(file   = availability_info_path,
                                header = TRUE,
                                sep    ='\t')

siRNA_sequences <- readDNAStringSet(sirnas)
siRNA_names <- names(siRNA_sequences)
sequences <- paste(siRNA_sequences)
siRNA_sequences <- data.frame(seq = sequences)
row.names(siRNA_sequences) <- siRNA_names

# no gaps in siRNAs
edit_table <- raw_table[raw_table$gaps == 0,] 
# minimum of 16 matches
edit_table <- edit_table[edit_table$matches >= minimum_matching_nucleotides,]
# query needs to start at pos 2 since it's the start of the seed sequence
edit_table <- edit_table[edit_table$query_start <= 2,] 
# Check if seed sequence is 100% correct
edit_table <- edit_table[ifelse(edit_table$query_start == 1, substr(edit_table$query_seq,2,8) == substr(edit_table$ref_seq,2,8), substr(edit_table$query_seq,1,7) == substr(edit_table$ref_seq,1,7) ),]
# Turn strand 'plus' to '+' and 'minus' to '-'
edit_table$strand <- ifelse(edit_table$strand == 'plus', '+', '-')

# Start empty data frame to put out results
df <- data.frame(siRNA_name=character(),
                 siRNA_seq=character(),
                 number_hit=numeric(),
                 annotation_available=logical(),
                 target_organism=character(),
                 target_chromosome=character(),
                 posistion_start=numeric(),
                 position_end=numeric(),
                 strand=factor(levels = c("+","-")),
                 target_id=character(),
                 target_rna_type=character(), # maybe convert to factor later on (allow only unique(gff$type))
                 target_biotype=character(),
                 target_parent=character(),
                 product=character(),
                 feature_start=numeric(),
                 feature_end=numeric(),
                 feature_strand=factor(levels = c("+","-")),
                 alignment_length=numeric(),
                 matches=numeric(),
                 mismatches=numeric(),
                 mismatch_locations=character())


# Count number of entries 
entry_count <- 1


edit_table[,'accession'] <- unlist(lapply(edit_table[, "ref_id"], function(x) {
  unlist(strsplit(x, ":"))[2]
}))
edit_table[,'ref_id'] <- unlist(lapply(edit_table[, "ref_id"], function(x) {
  unlist(strsplit(x, ":"))[1]
}))

edit_table <- edit_table[order(edit_table$accession),]


for (accession in unique(edit_table$accession)) {
  # Get row of current accession
  row_current_accession <- availability_info[which(availability_info$accession==accession),]
  annotation_available <- FALSE
  # If the annotation info file says an annotation is present: Annotation is parsed
  # //TODO: Currently only a short term fix. Problem is that some genomes don't get the genome ID pastet to the chromosome names
  #           which makes this if fail (regarding first if statement)
  if(!is.na(accession)){
    if (row_current_accession$annotation){
      gff <- read.gff(paste(dir_db, '/', row_current_accession$annotation_path, sep=''), na.strings = c('.'), GFF3 = TRUE)
      annotation_available <- TRUE
    } else {
      gff <- FALSE
    }
    
  } else {
    gff <- FALSE
  }
  print(paste('Analyzing: ', accession, sep = ''))
  # Extract all entries belonging to the current accession
  current_entries <- edit_table[which(edit_table$accession == accession),]

  for (row in 1:nrow(current_entries)) {
    
    current_row <- current_entries[row,]
    
    # Extract the siRNA sequence belonging to the current entry
    siRNA_seq <- siRNA_sequences[current_row[1,'query_id'],'seq']
    
    # Check if the chromosome is present in the gff file
    if (current_row$ref_id %in% unique(gff$seqid)) {
      # Extract all features of the gff file that overlap with the alignment position
      gff_relevant_entries <- gff[(gff$start <= current_row$ref_end) &
                                  (gff$end >= current_row$ref_start) &
                                  (gff$seqid == current_row$ref_id),]
      
      # Remove all entries of type region as they typically describe the whole chromosome
      gff_relevant_entries <- gff_relevant_entries[gff_relevant_entries$type != 'region',]
      # Check if entries got extracted
      if(nrow(gff_relevant_entries) > 0){
        for (gff_row in 1:nrow(gff_relevant_entries)) {
          current_gff_entry <- gff_relevant_entries[gff_row,]
          # If strandiness shall be considered then only siRNA aligning to the opposite strand of the feature are processed (as siRNA bind to the complement)
          #  Therefor the current gff entry will be skipped if the strand is the same
          if(regard_strandiness & current_row$strand == current_gff_entry$strand){
            next
          }
          
          # Parse attributes of gff entry
          attributes <- unlist(strsplit(current_gff_entry$attributes, ';'))
          
          # Get relevant gff information
          feature_id <- extract_attribute_info(attributes, 'ID')
          feature_biotype <- extract_attribute_info(attributes, 'biotype')
          feature_product <- extract_attribute_info(attributes, 'product')
          feature_parent <- extract_attribute_info(attributes, 'parent')
          feature_rna_type <- current_gff_entry$type
          feature_start <- current_gff_entry$start
          feature_end <- current_gff_entry$end
          feature_strand <- current_gff_entry$strand
          
          df <- rbind(df,data.frame(siRNA_name           = current_row$query_id,
                                    siRNA_seq            = siRNA_seq,
                                    number_hit           = entry_count,
                                    annotation_available = annotation_available,
                                    got_annotation_entry = TRUE,
                                    target_organism      = current_row$accession,
                                    target_chromosome    = current_row$ref_id,
                                    posistion_start      = current_row$ref_start,
                                    position_end         = current_row$ref_end,
                                    strand               = current_row$strand,
                                    target_id            = feature_id,
                                    target_rna_type      = feature_rna_type,
                                    target_biotype       = feature_biotype,
                                    target_parent        = feature_parent,
                                    product              = feature_product,
                                    feature_start        = feature_start,
                                    feature_end          = feature_end,
                                    feature_strand       = feature_strand,
                                    alignment_length     = current_row$alignment_length,
                                    matches              = current_row$matches,
                                    mismatches           = current_row$mismatches,
                                    mismatch_locations   = NA)) # TODO: get from both strings
        }
      } else {
        annotation_available <- annotation_available
        got_annotation_entry = FALSE
        feature_id <- NA
        feature_biotype <- NA
        feature_product <- NA
        feature_parent <- NA
        feature_rna_type <- NA
        feature_start <- NA
        feature_end <- NA
        feature_strand <- NA
        
        df <- rbind(df,data.frame(siRNA_name           = current_row$query_id,
                                  siRNA_seq            = siRNA_seq,
                                  number_hit           = entry_count,
                                  annotation_available = annotation_available,
                                  got_annotation_entry = got_annotation_entry,
                                  target_organism      = current_row$accession,
                                  target_chromosome    = current_row$ref_id,
                                  posistion_start      = current_row$ref_start,
                                  position_end         = current_row$ref_end,
                                  strand               = current_row$strand,
                                  target_id            = feature_id,
                                  target_rna_type      = feature_rna_type,
                                  target_biotype       = feature_biotype,
                                  target_parent        = feature_parent,
                                  product              = feature_product,
                                  feature_start        = feature_start,
                                  feature_end          = feature_end,
                                  feature_strand       = feature_strand,
                                  alignment_length     = current_row$alignment_length,
                                  matches              = current_row$matches,
                                  mismatches           = current_row$mismatches,
                                  mismatch_locations   = NA)) # TODO: get from both strings
      }
    } else {
      annotation_available <- annotation_available
      got_annotation_entry = FALSE
      feature_id <- NA
      feature_biotype <- NA
      feature_product <- NA
      feature_parent <- NA
      feature_rna_type <- NA
      feature_start <- NA
      feature_end <- NA
      feature_strand <- NA
      
      df <- rbind(df,data.frame(siRNA_name           = current_row$query_id,
                                siRNA_seq            = siRNA_seq,
                                number_hit           = entry_count,
                                annotation_available = annotation_available,
                                got_annotation_entry = got_annotation_entry,
                                target_organism      = current_row$accession,
                                target_chromosome    = current_row$ref_id,
                                posistion_start      = current_row$ref_start,
                                position_end         = current_row$ref_end,
                                strand               = current_row$strand,
                                target_id            = feature_id,
                                target_rna_type      = feature_rna_type,
                                target_biotype       = feature_biotype,
                                target_parent        = feature_parent,
                                product              = feature_product,
                                feature_start        = feature_start,
                                feature_end          = feature_end,
                                feature_strand       = feature_strand,
                                alignment_length     = current_row$alignment_length,
                                matches              = current_row$matches,
                                mismatches           = current_row$mismatches,
                                mismatch_locations   = NA)) # TODO: get from both strings
    }
    entry_count = entry_count + 1
  }
}

df_gene <- df[df$target_rna_type=="mRNA" & !is.na(df$target_rna_type=="mRNA"),]

# remove annotations to open up RAM 
#rm(annotation_info, annotation_list,siRNA_sequences)

# Sort df by organism names to only load one genome at a time in order to preserve RAM
occurences <- data.frame()
if(extract_coding_sequences){

  for (organism in unique(df$target_organism[df$annotation_available==TRUE])) {
    file_path_cds <- paste("/home/patrick/PhD/projects/download_data/", organism, '/cds_from_genomic.fna', sep='')
    tmp_cds_sequences <- readDNAStringSet(file_path_cds)
    pattern <- "\\[locus_tag=([^\\]]+)\\]"
    
    sequence_names <- names(tmp_cds_sequences)
    locus_tags <- unlist(lapply(sequence_names, function(x) extract_locus_tag(x,pattern)))
    
    # Extract all entries from the current organism which also have an rna_type
    tmp_df <- df[df$target_organism==organism & !is.na(df$target_rna_type),]
    # Extract all entries with gene as rna type
    tmp_df_gene <- tmp_df[tmp_df$target_rna_type == 'gene',]
    collect_indices <- list()
    
    for (row in 1:nrow(tmp_df_gene)) {
      tmp_locus_tag <- gsub("gene-","",tmp_df_gene[row,"target_id"])
      index_cds <- which(locus_tags == tmp_locus_tag)
      collect_indices <- c(collect_indices,index_cds)
    }
    
    tmp_occurences <- cbind(as.data.frame(table(locus_tags[unlist(collect_indices)])), organism=organism)
    #tmp_occurences <- cbind(tmp_occurences, cds_name = unique(sequence_names[unlist(collect_indices)]))
    occurences <- rbind(occurences,tmp_occurences)
    
    collect_indices <- unlist(unique(collect_indices))
    collect_cds <- tmp_cds_sequences[collect_indices]
    writeXStringSet(collect_cds, paste(dir_output, organism, '_hit_cds.fna', sep=''))
    rm(file_path_cds,tmp_cds_sequences,locus_tags)
  }
  print("before order")
  print(occurences)
  occurences <- occurences[order(occurences$organism,occurences$Freq,decreasing = TRUE),]
  colnames(occurences) <- c('locus_tag','number_hits','organism')
  occurences <- occurences[,c('organism','locus_tag','number_hits')]
  df_gene <- df_gene[order(df_gene$target_organism,df_gene$target_chromosome,df_gene$posistion_start,decreasing = TRUE),]
  
  print("after order")
  
  write.table(occurences, file=paste(dir_output,'amount_hits_GFP_vs_', group, '.tsv',sep = ""), quote=FALSE, sep='\t', col.names = TRUE, row.names = FALSE)
}

df_gene <- df_gene[order(df_gene$target_organism, -df_gene$alignment_length),]
row.names(df_gene) <- NULL
#TODO: filter double entries from df -> Currently has an entry for every RNA type which multiplies hits as all parents are present

## Add english names together with familiy and subfamiliy to list
ncbi_sheets <- read.table(file = paste(dir_base, 'insect_genomes_overview_ncbi.csv', sep = '/'),
                        header = TRUE,
                        sep=',')
insectBase_sheets <- read.table(file = paste(dir_base, 'insect_genomes_overview_insectbase.csv', sep = '/'),
                                header = TRUE,
                                sep=',')

# retrieve information from sheets document
sheets_information <- lapply(1:nrow(df_gene), function(x) {
  hits_ncbi <- which(df_gene[x,'target_organism'] == ncbi_sheets[,'assembly_ID'])
  hits_insectBase <- which(df_gene[x,'target_organism'] == gsub(' ', '_',insectBase_sheets[,'Species.name']))
  tmp_row <- list()
  if (length(hits_ncbi > 0 & hits_insectBase > 0)) {
    print("not supposed to happen")
  }
  if (length(hits_ncbi) == 1) {
    tmp_row['organism_latin_name'] <- ncbi_sheets[hits_ncbi,'Species.name']
    tmp_row['organism_english_name'] <- ncbi_sheets[hits_ncbi,'Public.name']
    tmp_row['organism_family'] <- ncbi_sheets[hits_ncbi,'Family.name']
    tmp_row['organism_subfamiliy'] <- ncbi_sheets[hits_ncbi,'Subfamily.name']
  } else if (length(hits_ncbi) > 1) {
    if (all(ncbi_sheets[hits_ncbi,'Species.name'] == ncbi_sheets[hits_ncbi[1],'Species.name']) &&
        all(ncbi_sheets[hits_ncbi,'Public.name'] == ncbi_sheets[hits_ncbi[1],'Public.name']) &&
        all(ncbi_sheets[hits_ncbi,'Family_name'] == ncbi_sheets[hits_ncbi[1],'Family.name']) &&
        all(ncbi_sheets[hits_ncbi,'Subfamily_name'] == ncbi_sheets[hits_ncbi[1],'Subfamily.name'])){
      tmp_row['organism_latin_name'] <- ncbi_sheets[hits_ncbi[1],'Species.name']
      tmp_row['organism_english_name'] <- ncbi_sheets[hits_ncbi[1],'Public.name']
      tmp_row['organism_family'] <- ncbi_sheets[hits_ncbi[1],'Family.name']
      tmp_row['organism_subfamiliy'] <- ncbi_sheets[hits_ncbi[1],'Subfamily.name']
    } else {
      tmp_row['organism_latin_name'] <- paste(ncbi_sheets[hits_ncbi,'Species.name'], collapse = ';')
      tmp_row['organism_english_name'] <- paste(ncbi_sheets[hits_ncbi,'Public.name'], collapse = ';')
      tmp_row['organism_family'] <- paste(ncbi_sheets[hits_ncbi,'Family.name'], collapse = ';')
      tmp_row['organism_subfamiliy'] <- paste(ncbi_sheets[hits_ncbi,'Subfamily.name'], collapse = ';')
    }
  } else if (length(hits_insectBase == 1)){
    tmp_row['organism_latin_name'] <- insectBase_sheets[hits_insectBase,'Species.name']
    tmp_row['organism_english_name'] <- insectBase_sheets[hits_insectBase,'Public.name']
    tmp_row['organism_family'] <- insectBase_sheets[hits_insectBase,'Family.name']
    tmp_row['organism_subfamiliy'] <- NA
  } else if (length(hits_insectBase > 1)) {
    if (all(insectBase_sheets[hits_insectBase,'Species.name'] == insectBase_sheets[hits_insectBase[1],'Species.name']) &&
        all(insectBase_sheets[hits_insectBase,'Public.name'] == insectBase_sheets[hits_insectBase[1],'Public.name']) &&
        all(insectBase_sheets[hits_insectBase,'Family.name'] == insectBase_sheets[hits_insectBase[1],'Family.name']) &&
        all(insectBase_sheets[hits_insectBase,'Subfamily.name'] == insectBase_sheets[hits_insectBase[1],'Subfamily.name'])){
      tmp_row['organism_latin_name'] <- insectBase_sheets[hits_insectBase[1],'Species.name']
      tmp_row['organism_english_name'] <- insectBase_sheets[hits_insectBase[1],'Public.name']
      tmp_row['organism_family'] <- insectBase_sheets[hits_insectBase[1],'Family.name']
      tmp_row['organism_subfamiliy'] <- insectBase_sheets[hits_insectBase[1],'Subfamily.name']
    } else {
      tmp_row['organism_latin_name'] <- paste(insectBase_sheets[hits_insectBase,'Species.name'], collapse = ';')
      tmp_row['organism_english_name'] <- paste(insectBase_sheets[hits_insectBase,'Public.name'], collapse = ';')
      tmp_row['organism_family'] <- paste(insectBase_sheets[hits_insectBase,'Family.name'], collapse = ';')
      tmp_row['organism_subfamiliy'] <- paste(insectBase_sheets[hits_insectBase,'Subfamily.name'], collapse = ';')
    }
  }
  return(tmp_row)
})





df_gene[,c('organism_latin_name','organism_english_name','organism_family','organism_subfamiliy')] <- do.call(rbind, lapply(sheets_information,as.data.frame))



write.table(df, file=paste(dir_output, 'results_ledprona_vs_', group, '.tsv',sep = ""), quote=FALSE, sep='\t', col.names = TRUE, row.names = FALSE)
write.table(df_gene, file=paste(dir_output,'genes_ledprona_vs_', group, '.tsv',sep = ""), quote=FALSE, sep='\t', col.names = TRUE, row.names = FALSE)